---
title: "DataProcessing1"
format: html
editor: visual
---

# Data processing

## Chargement des packages

```{r,warning=FALSE,message=FALSE}
library(tidyverse)
library(stringdist)
```

## Chargement des jeux de données

```{r}
priceGlob <- read_csv("../data/ECHO_DU_MARCHE.csv",locale = locale())

CatProd <- read_csv("../data/CatProduit.csv", locale = locale())
CatProdSupp <- read_delim("../data/CatProduitSupp.csv", delim = ";", locale = locale())
colnames(CatProdSupp) <- c("Categories","Produits")
CatProdSupp|>head()
#Transformation de la colonne PRODUITS en miniscule

priceGlob <- priceGlob |> mutate(PRODUITS=str_to_lower(PRODUITS))

CatProd <- CatProd |> mutate(Produits=str_to_lower(Produits))

# Affichage sampling de lignes
priceGlob |> sample_n(10)
```

## Evalutation de la distance

```{r warning=FALSE}
# matrice des distances
dataMat <- as_tibble(stringdistmatrix(CatProd$Produits,unique(priceGlob$PRODUITS),method ='lcs'))

# Ajout des produits dans un premier temps (cette colonne sera remplacé par Catégorie à la fin)
test <- bind_cols(unique(CatProd$Produits),dataMat)

# Utilisation de `map` order, afin de transformer les colonnes en lignes et opérer sur elles
# (1) Voir d'abord : map(test[-1],\(x) order(x)[1])
# Puck(1,y), pour appeler la ligne y de la colonne 1
resultMap <- map(test[-1],\(x) order(x)[1]) |> map(\(y) test |> pluck(1,y))
resultMapCol <- map(test[-1],\(x) order(x)[1])|> map(\(y) test |> pluck(1,y))



# Affectation des noms des produits
names(resultMap) <- unique(priceGlob$PRODUITS)
names(resultMapCol) <- unique(priceGlob$PRODUITS)

resultMap <- resultMap |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "Match")

resultMapCol <- resultMapCol |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "MatchScore")

head(resultMapCol)

as_tibble(resultMapCol)
#Affichage résultat
bind_cols(resultMap,resultMapCol$MatchScore) |> view()

CatProd <- bind_rows(CatProd,CatProdSupp)
head(CatProd)

write.csv(resultMap |> as_tibble(), "data.csv", row.names = FALSE)

resultMap |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "Match")


length(resultMap)

```

Conclusion : Moyennant une bonne distance, nous pourront avoir le moins d'erreurs possibles.

### Recherches de distances plus précises

```{r}
# matrice des distances
CatProd <- bind_rows(CatProd,CatProdSupp)
head(CatProd)

dataMat <- as_tibble(stringdistmatrix(CatProd$Produits,unique(priceGlob$PRODUITS),method ='soundex'))



```
