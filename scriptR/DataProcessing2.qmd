---
title: "DataProcessing1"
format: html
editor: visual
---

# Data processing

## Chargement des packages

```{r,warning=FALSE,message=FALSE}
library(tidyverse)
library(stringdist)
library(tidygeocoder)
library(sf)
```

## Chargement des jeux de données

```{r,warning=FALSE,message=FALSE}
# Jeu de données ECHO_DU_MARCHE
priceGlob <- read_csv("../data/ECHO_DU_MARCHE.csv",locale = locale())

# Suppression des doublons dans la base de données
priceGlob <- unique(priceGlob)

# Jeu de données Contenant les catégories des produits (avec les orthographes approximatifs)
CatProd <- read_csv("../data/CatProduit.csv", locale = locale())

# Jeu de données contenant les produits inexistant dans CatProd
CatProdSupp <- read_csv2("../data/CatProduitSupp.csv", locale = locale())
priceGlob <- read_csv("../data/ECHO_DU_MARCHE.csv",locale = locale())

CatProd <- read_csv("../data/CatProduit.csv", locale = locale())
CatProdSupp <- read_delim("../data/CatProduitSupp.csv", delim = ";", locale = locale())

colnames(CatProdSupp) <- c("Categories","Produits")

# Concaténation des jeux de données CatProd et CatProdSupp
CatProd <- bind_rows(CatProd,CatProdSupp)

# Transformation de la colonne PRODUITS en miniscule afin de faciliter le matching

priceGlob <- priceGlob |> mutate(PRODUITS=str_to_lower(PRODUITS))

CatProd <- CatProd |> mutate(Produits=str_to_lower(Produits))

```

## Transformation des colonnes

La difficulté majeure dans le processus réside dans la correspondance des noms des produits d'un dataset à un autre.\
Ces noms diffèrent dans l'orthograghe. Pour cela nous le faisons en deux étapes:\
- **Matching** : Un matching est fait dans un premier avec les colonnes des datasets au nombre de lignes réduits (ceci afin d'éviter d'étendre l'opération sur les \~ 47 000 lignes du dataset ECHO_MARCHE).\
- **Jointure** : Une jointure finale est faite dans but ramener les correspondances attendues vers le grand jeu de données.\

### Matching :

Nous établissons ici une correspondance entre les produits de `priceGlob(ECHO_DU_MARCHE)` et `CatProd`

## Evalutation de la distance

```{r ,warning=FALSE}

# matrice des distances
# Nous formons la matrice des distances avec la méthode "lcs"
dataMat <- as_tibble(stringdistmatrix(CatProd$Produits,unique(priceGlob$PRODUITS),method ='lcs'))

# Récupération des colonnes produits et catégories du dataset CatProd
test <- bind_cols(CatProd,dataMat)
# head(test)

# Utilisation de `map` order, afin de transformer les colonnes en lignes et opérer sur elles
# (1) Voir d'abord : map(test[-1],\(x) order(x)[1])
# Puck(1,y), pour appeler la ligne y de la colonne 1
resultCat <- map(test[-c(1,2)],\(x) order(x)[1]) |>
  map(\(y) test |>
        pluck(1,y))
# Puck(1,y), pour appeler la ligne y de la colonne 2
resultProd <- map(test[-c(1,2)],\(x) order(x)[1])|>
  map(\(y) test |>
        pluck(2,y))

# Affectation des noms des produits
names(resultCat) <- unique(priceGlob$PRODUITS)
names(resultProd) <- unique(priceGlob$PRODUITS)

# Transformation des listes resultMap et resultMapCol en tibble moyennant un pivotement

resultCat <- resultCat |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "Categories")

resultProd <- resultProd |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "MatchProduit")

# Formation du dataset : CatGlob , qui correspond contient les produits et leurs catégories
# Nous retirons le produits afin [-1] afin d'éviter les répétitions dans les colonnes
CatGlob<- bind_cols(resultCat,resultProd[-1])

CatProd <- bind_rows(CatProd,CatProdSupp)
head(CatProd)


```

### Jointure

L'inclusion de la colonne catégorie dans le dataset`priceGlob`, se fait au moyen de jointure. La jointure se fera ici avec le dataset `CatGlob`

```{r}
# Retrait de la colonne matchingProduit dans la jointure
priceGlob <- left_join(priceGlob,CatGlob[-3], by=join_by("PRODUITS"=="Produit"),keep = FALSE)

# Nom des colonnes
namesCol <- colnames(priceGlob)

# Changement de nom de la colonne `catégories`
colnames(priceGlob)<- c(namesCol[1:(length(namesCol)-1)],"SPECIFICITE")

# Résultat
priceGlob

```

### Gestion des valeurs manquantes

Deux cas de figures s'assimilent à l'observation de valeurs manquantes dans notre dataset:\
1. Une indisponibilité du produits dans la région concernée\
2. Un défaut de mesure des prix sur la période concernée\

Par suite nous considérons le cas 2.

#### Imputations

Pour chaque valeur manquante dans une région, une imputation par un arbitrage. D'un côté par l'imputation du prix observé chez la ville la plus proche, et de l'autre par le prix observé aux semaines qui environnent l'obervation de la valeur manquante.

##### Détection des villes les plus proches

Les villes aux prix manquants sur une période sont retrouvées dans un premier temps, puis ces valeurs manquantes sont imputées par la moyenne des valeurs observées dans les autres villes.

```{r}
region <- unique(priceGlob$VILLE) |> as_tibble()

adressRegion <- region |> geocode(value)

adressRegionGeo <- adressRegion |> st_as_sf(coords = c("long","lat")) |> st_set_crs(4326)

# Distance les plus proches
centro <- st_centroid(adressRegionGeo$geometry) 

DD <- st_distance(centro,centro,which = "Frechet")

matching <- apply(DD,2 ,order) |> as_tibble() |> slice(2) |> map(~ region |> pluck(1,.x))

names(matching) <- region$value

matching
```

Fonction permettant d'affecter les valeurs d'une liste selon la proximité des villes. Nous avons ici 4 villes:

```{r}
# Ajout d'un identifant pour les colonnes 
priceGlob |> mutate(IDENTIFIANT=str_c("ENR",1:dim(priceGlob)[1]))
priceGlob |> 
  pivot_wider(names_from = VILLE,values_from =PRIX) |>
  slice(6) |>
  select(MAN) |> 
  pluck(1,1)

priceGlob |>
  pivot_wider(names_from = VILLE,values_from =PRIX,values_fn = ~first(.x)) |>
  rowwise(PRODUITS) |> 
  select(c(PRODUITS,ABIDJAN:KORHOGO))

priceGlob |> filter(MOIS=="janvier",
                    DATE==mdy("1/6/2020"),
                    CATEGORIE=="PRODUITS VIVRIERS",
                    `SOUS-CATEGORIE`=="PRODUITS DE SAISON",
                    PRODUITS=="citron (kg)",
                    VILLE=="ABIDJAN")
priceGlob |> dim()

priceGlob 
```

```{r,warning=FALSE}
for (i in 1:dim(priceGlob)) {
  
}

# Imputation d'une liste d'éléments
NomVille <- c("ABIDJAN","SANPEDRO", "BOUAKE", "YAMOUSSOUKRO", "MAN","KORHOGO")

which(NomVille==c("BOUAKE", "YAMOUSSOUKRO"))

vecTest1 <- c(800,NA,500,NA,NA,NA)

# Récupération des villes aux valeurs non manquantes
which(!is.na(vecTest1)) # Position

vecTest1[which(!is.na(vecTest1))]

vecTest1[which(is.na(vecTest1))]

# Fonction qui rammène la plus proche d'un ensemble de ville

villeProche <- function(ville,VilleDispo,MatriceDistance){
  
  NomVille <- c("ABIDJAN","SANPEDRO", "BOUAKE", "YAMOUSSOUKRO", "MAN","KORHOGO")
  
  # Récupération des villes aux valeurs non manquantes
  VilleDispo <- NomVille[which(!is.na(VilleDispo))]
  
  # Ordre des villes proches : Ordre relatif au nombre d'éléments
  ordreVilleProche <-  which(NomVille%in%VilleDispo)
  
  # Ordre de ville entrée
  ordreVille<- which(NomVille==ville)
  
  # Récupération du nom de la ville la plus proche
  
  ## Vecteur distance de la ville entrée en paramètre
   vecteurDistance <- MatriceDistance|> apply(2 ,order)|> as_tibble() |> pluck(ordreVille)
  
  ## Ordre la ville la plus proche
  ordreVilleProche <- ordreVilleProche |>
    map_dbl(~which(vecteurDistance==.x)) |>
    which.min() 
  
  ## Nom de la ville la plus proche
  NomVilleProche<- NomVille[ordreVille[ordreVilleProche]]
  
  return(ordreVilleProche)
}

villeProche("KORHOGO",c(800,NA,500,NA,NA,NA),DD)


## Test de proximité
vec <- DD |> apply(2 ,order)|> as_tibble() |> pluck(2)
vec

c(2,6) |> map_dbl(~which(vec==.x)) |> which.min()

which(c("ABIDJAN","SANPEDRO", "BOUAKE", "YAMOUSSOUKRO", "MAN","KORHOGO")%in%c("KORHOGO","BOUAKE"))


```

janvier 2020-01-06 2020 PRODUITS VIVRIERS PRODUITS DE SAISON citron (kg) kilogramme
