---
title: "DataProcessing1"
format: html
editor: visual
---

# Data processing

## Chargement des packages

```{r,warning=FALSE,message=FALSE}
library(tidyverse)
library(stringdist)
```

## Chargement des jeux de données

```{r,warning=FALSE,message=FALSE}
# Jeu de données ECHO_DU_MARCHE
priceGlob <- read_csv("../data/ECHO_DU_MARCHE.csv",locale = locale())

# Jeu de données Contenant les catégories des produits (avec les orthographes approximatifs)
CatProd <- read_csv("../data/CatProduit.csv", locale = locale())

# Jeu de données contenant les produits inexistant dans CatProd
CatProdSupp <- read_csv2("../data/CatProduitSupp.csv", locale = locale())

# COncaténation des jeux de données CatProd et CatProdSupp
CatProd <- bind_rows(CatProd,CatProdSupp)

# Transformation de la colonne PRODUITS en miniscule afin de faciliter le matching

priceGlob <- priceGlob |> mutate(PRODUITS=str_to_lower(PRODUITS))

CatProd <- CatProd |> mutate(Produits=str_to_lower(Produits))

```

## Transformation des colonnes

La difficulté majeur dans le processus réside dans la correspondance des noms des produits d'un dataset à un autre. Ces noms diffèrent dans l'orthograghe. Pour cela nous le faisons en deux étapes:
- Matching : Un matching est fait dans un premier avec les colonnes réduits des datasets (ceci afin d'éviter d'étendre l'opération sur les ~ 47 000 lignes du dataset ECHO_MARCHE)
- Jointure : Une jointure finale est faite dans but ramener les correspondances attendues vers le grand jeu de données.


### Matching :
Nous établissons ici une correspondance entre les produits de `priceGlob(ECHO_DU_MARCHE)` et `CatProd`
```{r}
# matrice des distances
# Nous formons la matrice des distances avec la méthode "lcs"
dataMat <- as_tibble(stringdistmatrix(CatProd$Produits,unique(priceGlob$PRODUITS),method ='lcs'))

# Récupération des colonnes produits et catégories du dataset CatProd
test <- bind_cols(CatProd,dataMat)
# head(test)

# Utilisation de `map` order, afin de transformer les colonnes en lignes et opérer sur elles
# (1) Voir d'abord : map(test[-1],\(x) order(x)[1])
# Puck(1,y), pour appeler la ligne y de la colonne 1
resultCat <- map(test[-c(1,2)],\(x) order(x)[1]) |> map(\(y) test |> pluck(1,y))
# Puck(1,y), pour appeler la ligne y de la colonne 2
resultProd <- map(test[-c(1,2)],\(x) order(x)[1])|> map(\(y) test |> pluck(2,y))

# Affectation des noms des produits
names(resultCat) <- unique(priceGlob$PRODUITS)
names(resultProd) <- unique(priceGlob$PRODUITS)

# Transformation des listes resultMap et resultMapCol en tibble moyennant un pivotement

resultCat <- resultCat |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "Categories")

resultProd <- resultProd |> as_tibble() |>
  pivot_longer(everything(),names_to="Produit", values_to = "MatchProduit")

# Formation du dataset : CatGlob , qui correspond contient les produits et leurs catégories
# Nous retirons le produits afin [-1] afin d'éviter les répétitions dans les colonnes
CatGlob<- bind_cols(resultCat,resultProd[-1])

# Affichage du résulat
CatGlob |> view()


```


### Jointure


